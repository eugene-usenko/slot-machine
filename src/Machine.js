/**
 * Generates random number in range [0, max).
 * @param  {Number} max Max value(exclusive) of the generator.
 */
export const rand = max =>
    Math.floor(Math.random() * max);

/**
 * Utility method which determines, does hits matches given rule.
 *
 * @param {String} hits is a sequance of character which were
 * evaluated from the line and generated stop values. For short
 * this is string which consists from sybols of the line.
 *
 * @param {String} rule is special char sequance, which exists
 * from symbols represented on the reel. Symbols can be one of
 * three types:
 * 1) regular  - any lower case character alphabet
 * 2) special  - any upper case character alphabet
 * 3) wildcard - * symbol which actualy meand 'any symbol'
 *
 * Rule can be shorter than hits string, that means it's not
 * necessary 'to match' full length of the hits string.
 */
export const matches = (hits, rule) => {
    const isSpecial = c => c === c.toUpperCase();
    const isWild = c => c === '*';

    const matchedLen = [...rule].reduce((len, r, i) => {
        const h = hits.charAt(i);
        if (!h) return len;

        if (isWild(r)) return len + 1;
        if (isSpecial(h) && !isSpecial(r)) return len + 1;
        if (h === r) return len + 1;
        return len;
    }, 0);
    return matchedLen === rule.length;
};

/**
 * Class represent abstration for Slot machine. Some terminolgy and
 * format used by class:
 *
 * - line TODO
 * - reel TODO
 * - hits TODO
 * - stops TODO
 * - path TODO
 *
 * Machine Id is an unique identifier across all machines. This
 * field is used internaly to loock up machine or corresponding
 * free-spin machine(see below).
 *
 * By internal convention, every machine which has freeespins feature
 * is represented by two configs. Their Ids must follow special rules.
 * If regular machine name is 'xxx', then corresponding machine with
 * free-spins must be 'xxx-freespins'
 *
 * Name field is a human readable name of the machine. There is no
 * restrictions or special rules for that value.
 *
 * Machine version is represented by two digits x.y. Where x is an
 * major version must be incremented after new feature introduction.
 * y - minor version or revision number, should be used for bugfixes
 * and minor improvements.
 *
 * Only few methods are public API, the rest are used for internal
 * purposes and simuation(for machine payout calculation). Public
 * API should be re-exported in the index.js file, in order to make
 * them available externaly and give a hint which methods should be
 * used for regular gameplay process.
 *
 * @see index.js
 */
export class Machine {

    constructor(config, dev = false) {
        this.id = config.id;
        this.name = config.name;
        this.version = config.version;
        this.lines = config.lines;
        this.reels = config.reels;
        this.paytable = config.paytable;
        this.multipliers = config.multipliers;
        this.minigames = config.minigames;
        this.expected = config.expected;
    }

    /**
     * Peformes spin for the passed lines.
     *
     * @param {Object} lines
     *
     * @param {Array}  stops array which contains generated
     * by RNG stop positions for every reel. Value at certain
     * position corresponds to stop value on the certain reel.
     * By default this parameter will be generated by machine
     * itself, but it can be passed to get spin result for
     * cpecific stops combination. It's required for simulator
     * which performs full cycle calculation and generates
     * stops one by one.
     *
     * @return {Object} object which contains two fields:
     * - stops - stop value for the virtual reels represented
     * as array of intengers.
     * - outcome - array which contains 'wins' for lines whith
     * succes spin result.
     */
    spin(lines = this.getLines(), stops = this.getStops()) {
        const outcome = lines.map(line => {
            const hits = this.toHits(line, stops);
            return {
                line: line,
                pays: this.getPays(hits),
                minigame: this.getMinigame(hits),
                multiplier: this.getMultiplier(hits)
            };
        });
        return { stops, outcome };
    }

    /**
     * @returns {Array} array of stop symbols. Length of
     * array corresponds to number of reels. Value at the
     * certain index is always in range [0,reel.length).
     * @see rand
     */
    getStops = () => this.reels.map(reel => rand(reel.length));

    /**
     * Converts stop value indexes to actual reel symbols(for
     * specific line).
     *
     * For the single line 'symbol index' on the reel will be
     * calculated as offset = (stop value postion + line value
     * position). In case offset exceeds line length(stop value
     * is the last symbol on the reel and line value is bigger
     * than 0), then offset will start from the reel beggining -
     * reel is considered as cyrcle buffer.
     *
     * @param {Array} line array contains values which
     * represents line path on the machine. Line alway contains
     * relative values(from top left corner).
     *
     * @param {Array} stops array which contains generated by
     * RNG values. Every stop value(at certain index) must
     * always be in range [0, len), where len is length of the
     * reel.
     *
     * @returns {Array} actual symbols of the reel(for the line).
     */
    toHits = (line, stops) =>
        stops.reduce((hits, stop, index) => {
            const len = this.reels[index].length;
            var offset = stop + line[index];
            if (offset >= len) offset -= len;
            return hits + this.reels[index].charAt(offset);
        }, '');

    getPays = hits =>
        Object.keys(this.paytable).reduce((pays, rule) => {
            const p = this.paytable[rule];
            return matches(hits, rule) ? Math.max(p, pays) : pays;
        }, 0);

    getMultiplier = hits =>
        Object.keys(this.multipliers).reduce((multiplier, rule) => {
            const m = this.multipliers[rule];
            return matches(hits, rule) ? Math.max(m, multiplier) : multiplier;
        }, 1);

    getMinigame = hits =>
        Object.keys(this.minigames).reduce((minigame, rule) => {
            if (minigame) return minigame;
            return matches(hits, rule) ? this.minigames[rule] : undefined;
        }, undefined);

    getLines = () => this.lines;

    getNumberOfLines = () => this.lines.length;

    /**
     * Removes all non public fields from machine. Once
     * machine is 'sanitized' it can be safely send to
     * the clie client.
     */
    sanitize = () => {
        const copy = Object.assign({}, this);
        delete copy['version'];
        delete copy['minigames'];
        delete copy['multipliers'];
        delete copy['expected'];
        return Object.freeze(copy);
    };
}
